# Отчет по лабораторной работе: Порождающие паттерны проектирования
## Тема: Реализация паттерна «Фабричный метод» на C#

### 1. Цель работы
*   Изучить концепцию порождающих паттернов проектирования.
*   Реализовать паттерн «Фабричный метод» для создания гибкой системы уведомлений.
*   Освоить разделение ответственности между классами-создателями (Creators) и классами-продуктами (Products).
*   Разработать GUI-приложение (Windows Forms) для демонстрации работы системы.

### 2. Описание предметной области
В рамках работы спроектирована система рассылки уведомлений через три независимых канала:
1.  **Email**: поддерживает вложение файлов и HTML-верстку.
2.  **SMS**: поддерживает ограничение длины (160 символов) и режим Flash-сообщения.
3.  **Telegram**: поддерживает Markdown-разметку, добавление интерактивных кнопок и обновление webhook.

### 3. Архитектурное решение
Для решения задачи выбран паттерн **Фабричный метод** в сочетании с элементами паттерна **Шаблонный метод**.

#### Основные компоненты:
*   **Иерархия Продуктов (`Notification`)**: определяет интерфейс инструментов отправки.
*   **Иерархия Создателей (`NotificationSender`)**: управляет ресурсами (API-ключами, настройками) и процессом создания продуктов.
*   **Метод `Configure` (Hook)**: Продвинутая техника, позволяющая конкретным фабрикам настраивать специфические свойства (вложения, кнопки) созданного продукта перед его отправкой, не нарушая общую логику базового класса.

### 4. Реализация системы (бизнес-логика)

#### Базовая абстракция отправителя:
```csharp
public abstract class NotificationSender
{
    // Фабричный метод
    protected abstract Notification create_notification(string recipient);

    // Хук для настройки уникальных свойств продукта
    protected virtual void Configure(Notification notification) { }

    // Шаблонный метод, описывающий единый бизнес-процесс
    public void send_notice(string recipient, string message)
    {
        Notification notification = create_notification(recipient);
        Configure(notification); // Уникальная настройка подклассом

        string preparedMessage = $"[{DateTime.Now:HH:mm:ss}] {message}";
        
        // Общая валидация для всех типов
        if (preparedMessage.Length > notification.MaxLength)
        {
            preparedMessage = preparedMessage.Substring(0, notification.MaxLength);
        }

        notification.Send(preparedMessage);
    }
}

## 5. Сравнительный анализ

### Вариант без паттерна:
В процедурном подходе используется один класс-сервис с множеством условных операторов (`if-else` или `switch`).

**Проблема 1:** Нарушение принципа Open/Closed (необходимо изменять уже работающий код при добавлении нового канала).  
**Проблема 2:** Нарушение принципа Single Responsibility (один метод знает детали реализации всех каналов связи).  
**Проблема 3:** Дублирование кода (валидация и логирование времени копируются в каждый блок).

### Вариант с паттерном:
**Преимущество 1:** Каждый класс изолирован и отвечает только за свою задачу.  
**Преимущество 2:** Легкое расширение — добавление нового канала (например, WhatsApp) не требует изменения существующего кода.  
**Преимущество 3:** Централизованный контроль над общим процессом (время, валидация) реализован в базовом классе.

---

## 6. Описание графического интерфейса

Приложение реализовано на платформе **Windows Forms**.  

Интерфейс динамически адаптируется под выбранный канал связи, отображая только актуальные настройки (например, список файлов для Email или поле ввода кнопок для Telegram).  

Реализован перехват стандартного вывода консоли в окно лога (через `TextBoxWriter`), что позволяет видеть результат работы фабрики в режиме реального времени.

---

## 7. Выводы

В ходе выполнения работы был реализован паттерн «Фабричный метод» на языке C#.  

Архитектура системы позволила успешно разделить:
- логику управления ресурсами (**Sender**),
- логику исполнения задачи (**Notification**).

Применение виртуального метода `Configure` обеспечило гибкую настройку уникальных характеристик продуктов при сохранении целостности общего бизнес-алгоритма.